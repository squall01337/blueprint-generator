<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blueprint AI Studio - Unreal Engine 5</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00d4ff;
            --primary-dark: #0099cc;
            --bg-dark: #0a0a0f;
            --bg-medium: #1a1a2e;
            --bg-light: #2a2a3e;
            --text-primary: #ffffff;
            --text-secondary: #a0a0b0;
            --success: #00ff88;
            --error: #ff4466;
            --warning: #ffaa00;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, var(--bg-dark) 0%, var(--bg-medium) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Header Bar */
        .header-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(10, 10, 15, 0.95);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 24px;
            z-index: 1000;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 20px;
            font-weight: 600;
            color: var(--primary);
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
        }

        .logo-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .api-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            font-size: 13px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--error);
        }

        .status-dot.active {
            background: var(--success);
            box-shadow: 0 0 10px var(--success);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        /* Main Layout */
        .main-content {
            display: flex;
            width: 100%;
            margin-top: 60px;
            height: calc(100vh - 60px);
        }

        /* Sidebar Chat */
        .sidebar {
            width: 400px;
            background: rgba(26, 26, 46, 0.6);
            backdrop-filter: blur(20px);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }

        .sidebar.collapsed {
            width: 60px;
        }

        .api-setup {
            padding: 16px;
            background: rgba(0, 212, 255, 0.05);
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        }

        .api-setup.hidden {
            display: none;
        }

        .api-input-group {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .input-field {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 10px;
            border-radius: 8px;
            font-size: 13px;
            transition: all 0.3s ease;
        }

        .input-field:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(0, 212, 255, 0.2);
        }

        .btn {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            font-size: 14px;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 212, 255, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-icon {
            padding: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        /* Chat Area */
        .chat-container {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            scroll-behavior: smooth;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(0, 212, 255, 0.3);
            border-radius: 3px;
        }

        .message {
            margin-bottom: 20px;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .message-avatar {
            width: 24px;
            height: 24px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
        }

        .message.user .message-avatar {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        .message.assistant .message-avatar {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        }

        .message-content {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            line-height: 1.6;
        }

        .message.user .message-content {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
            border-color: rgba(102, 126, 234, 0.3);
            margin-left: 32px;
        }

        .message.assistant .message-content {
            margin-left: 32px;
        }

        .chat-input-container {
            padding: 16px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .chat-input-wrapper {
            display: flex;
            gap: 12px;
            align-items: flex-end;
        }

        .chat-input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--text-primary);
            padding: 12px;
            border-radius: 12px;
            resize: none;
            min-height: 48px;
            max-height: 120px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            outline: none;
            border-color: var(--primary);
            background: rgba(255, 255, 255, 0.08);
        }

        .quick-actions {
            display: flex;
            gap: 8px;
            margin-top: 12px;
            flex-wrap: wrap;
        }

        .quick-btn {
            padding: 6px 12px;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            color: var(--primary);
            border-radius: 16px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .quick-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            transform: translateY(-1px);
        }

        /* Blueprint Viewer Area */
        .viewer-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-dark);
        }

        /* Tabs */
        .tabs-container {
            display: flex;
            background: rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0 12px;
            gap: 4px;
            align-items: center;
            min-height: 48px;
        }

        .tab {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.3s ease;
            max-width: 200px;
        }

        .tab:hover {
            background: rgba(255, 255, 255, 0.08);
        }

        .tab.active {
            background: var(--bg-dark);
            color: var(--text-primary);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: none;
        }

        .tab-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .tab-close {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab-close:hover {
            background: rgba(255, 68, 102, 0.2);
            color: var(--error);
        }

        .new-tab-btn {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 212, 255, 0.1);
            border: 1px solid rgba(0, 212, 255, 0.3);
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--primary);
        }

        .new-tab-btn:hover {
            background: rgba(0, 212, 255, 0.2);
        }

        /* Canvas Area */
        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .canvas-controls {
            position: absolute;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 100;
        }

        .control-group {
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 8px;
            padding: 4px;
            backdrop-filter: blur(10px);
        }

        .control-btn {
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: var(--text-primary);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            color: var(--primary);
        }

        .control-btn.active {
            background: rgba(0, 212, 255, 0.3);
            color: var(--primary);
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }

        canvas:active {
            cursor: grabbing;
        }

        /* Info Panel */
        .info-panel {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            display: flex;
            gap: 24px;
            z-index: 100;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .info-label {
            color: var(--text-secondary);
        }

        .info-value {
            color: var(--primary);
            font-weight: 600;
        }

        /* Loading State */
        .loading-spinner {
            display: none;
            width: 32px;
            height: 32px;
            border: 3px solid rgba(0, 212, 255, 0.2);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            flex-shrink: 0; /* Empêche de rétrécir */
        }

        .loading-spinner.active {
            display: block;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Toast Notifications */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 16px 24px;
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(20px);
            border-radius: 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            z-index: 2000;
            animation: slideUp 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: var(--error);
        }

        .toast-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        .toast.success .toast-icon {
            background: var(--success);
            color: var(--bg-dark);
        }

        .toast.error .toast-icon {
            background: var(--error);
            color: white;
        }

        /* Responsive */
        @media (max-width: 1024px) {
            .sidebar {
                width: 350px;
            }
        }

        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .sidebar {
                width: 100%;
                height: 50vh;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .viewer-container {
                height: 50vh;
            }
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Header -->
        <div class="header-bar">
            <div class="logo">
                <div class="logo-icon">🎮</div>
                <span>Blueprint AI Studio</span>
            </div>
            <div class="header-actions">
                <div class="api-indicator">
                    <div class="status-dot" id="apiStatus"></div>
                    <span id="apiStatusText">Déconnecté</span>
                </div>
                <button class="btn btn-secondary btn-icon" onclick="clearConversation()" title="Nouvelle conversation">
                    🔄
                </button>
                <button class="btn btn-secondary btn-icon" onclick="exportCurrentBlueprint()" title="Exporter">
                    📥
                </button>
                <button class="btn btn-secondary btn-icon" onclick="showHelp()" title="Aide">
                    ❓
                </button>
            </div>
        </div>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Sidebar Chat -->
            <div class="sidebar" id="sidebar">
                <div class="api-setup" id="apiSetup">
                    <div style="font-size: 13px; color: var(--primary); margin-bottom: 8px;">
                        🔑 Configuration API
                    </div>
                    <div class="api-input-group">
                        <input type="password" class="input-field" id="apiKey" placeholder="Clé API Claude...">
                        <button class="btn btn-icon" onclick="saveApiKey()" title="Sauvegarder">💾</button>
                        <button class="btn btn-secondary btn-icon" onclick="testApiConnection()" title="Tester">🔌</button>
                    </div>
                </div>

                <div class="chat-container">
                    <div class="chat-messages" id="chatMessages">
                        <div class="message assistant">
                            <div class="message-header">
                                <div class="message-avatar">🤖</div>
                                <span>Assistant Blueprint</span>
                            </div>
                            <div class="message-content">
                                Bienvenue dans Blueprint AI Studio ! 
                                
Je peux créer pour vous des Blueprints pour Unreal Engine 5.5/5.6.

Configurez d'abord votre clé API Claude, puis demandez-moi n'importe quel Blueprint. Les Blueprints générés s'ouvriront automatiquement dans de nouveaux onglets.

💡 Exemples : "Crée une porte automatique", "Système de plateforme mobile", "Téléporteur avec particules"
                            </div>
                        </div>
                    </div>

                    <div class="loading-spinner" id="loadingSpinner"></div>

                    <div class="chat-input-container">
                        <div class="chat-input-wrapper">
                            <textarea class="chat-input" id="chatInput" 
                                placeholder="Décrivez le Blueprint que vous souhaitez créer..."
                                onkeydown="handleChatKeypress(event)"></textarea>
                            <button class="btn" onclick="sendMessage()" id="sendBtn">
                                Envoyer
                            </button>
                        </div>
                        <div class="quick-actions">
                            <div class="quick-btn" onclick="quickPrompt('porte automatique avec trigger')">🚪 Porte</div>
                            <div class="quick-btn" onclick="quickPrompt('plateforme mobile entre deux points')">📦 Plateforme</div>
                            <div class="quick-btn" onclick="quickPrompt('pickup qui tourne et flotte')">✨ Pickup</div>
                            <div class="quick-btn" onclick="quickPrompt('téléporteur avec effets')">🌀 Téléporteur</div>
                            <div class="quick-btn" onclick="quickPrompt('interrupteur qui allume des lumières')">💡 Interrupteur</div>
                            <div class="quick-btn" onclick="quickPrompt('modifie le Blueprint actuel pour ajouter un son')" style="background: rgba(255, 170, 0, 0.1); border-color: rgba(255, 170, 0, 0.3); color: #ffaa00;">🔧 Modifier</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Blueprint Viewer -->
            <div class="viewer-container">
                <div class="tabs-container" id="tabsContainer">
                    <div class="new-tab-btn" onclick="createNewTab()" title="Nouveau Blueprint">+</div>
                </div>

                <div class="canvas-wrapper">
                    <div class="canvas-controls">
                        <div class="control-group">
                            <button class="control-btn" onclick="zoomIn()" title="Zoom +">🔍</button>
                            <button class="control-btn" onclick="zoomOut()" title="Zoom -">🔍</button>
                            <button class="control-btn" onclick="resetView()" title="Reset">⟲</button>
                            <button class="control-btn" onclick="fitToView()" title="Ajuster">⊡</button>
                        </div>
                        <div class="control-group">
                            <button class="control-btn" onclick="autoArrange()" title="Auto-arrange">🔧</button>
                            <button class="control-btn active" id="labelsBtn" onclick="toggleLabels()" title="Labels">📝</button>
                            <button class="control-btn active" id="gridBtn" onclick="toggleGrid()" title="Grille">⊞</button>
                        </div>
                    </div>

                    <canvas id="blueprintCanvas"></canvas>

                    <div class="info-panel">
                        <div class="info-item">
                            <span class="info-label">Nodes:</span>
                            <span class="info-value" id="nodeCount">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Connexions:</span>
                            <span class="info-value" id="connectionCount">0</span>
                        </div>
                        <div class="info-item">
                            <span class="info-label">Zoom:</span>
                            <span class="info-value" id="zoomLevel">100%</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // URL de ton Cloudflare Worker
        const WORKER_API_URL = 'https://blueprint-api.squall-justice.workers.dev/api';
        
        // Configuration globale
        let apiKey = '';
        let currentTabId = null;
        let tabs = {};
        let showLabels = false;
        let showGrid = true;

        // Canvas configuration
        const canvas = document.getElementById('blueprintCanvas');
        const ctx = canvas.getContext('2d');
        const NODE_WIDTH = 250;
        const NODE_MIN_HEIGHT = 80;
        const PIN_HEIGHT = 30;
        const PIN_RADIUS = 6;
        const HEADER_HEIGHT = 35;

        // Tab management
        function generateTabId() {
            return 'tab_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function createNewTab(name = 'Nouveau Blueprint', blueprintData = null) {
            const tabId = generateTabId();
            
            tabs[tabId] = {
                name: name,
                blueprintData: blueprintData,
                zoom: 1,
                panX: 0,
                panY: 0
            };

            renderTabs();
            switchToTab(tabId);
            
            if (blueprintData) {
                setTimeout(() => {
                    autoArrange();
                    fitToView();
                }, 100);
            }
            
            return tabId;
        }

        function renderTabs() {
            const container = document.getElementById('tabsContainer');
            const existingTabs = container.querySelectorAll('.tab');
            existingTabs.forEach(tab => tab.remove());

            Object.keys(tabs).forEach(tabId => {
                const tab = tabs[tabId];
                const tabElement = document.createElement('div');
                tabElement.className = 'tab' + (tabId === currentTabId ? ' active' : '');
                tabElement.innerHTML = `
                    <span class="tab-title">${tab.name}</span>
                    <span class="tab-close" onclick="closeTab('${tabId}', event)">×</span>
                `;
                tabElement.onclick = (e) => {
                    if (!e.target.classList.contains('tab-close')) {
                        switchToTab(tabId);
                    }
                };
                
                const newTabBtn = container.querySelector('.new-tab-btn');
                container.insertBefore(tabElement, newTabBtn);
            });
        }

        function switchToTab(tabId) {
            if (!tabs[tabId]) return;
            
            // Sauvegarder l'état du tab actuel
            if (currentTabId && tabs[currentTabId]) {
                const currentTab = tabs[currentTabId];
                currentTab.zoom = getCurrentZoom();
                currentTab.panX = getCurrentPanX();
                currentTab.panY = getCurrentPanY();
            }

            currentTabId = tabId;
            const tab = tabs[tabId];
            
            // Restaurer l'état du nouveau tab
            setCanvasState(tab);
            renderTabs();
            drawBlueprint();
        }

        function closeTab(tabId, event) {
            event.stopPropagation();
            
            delete tabs[tabId];
            
            if (tabId === currentTabId) {
                const remainingTabs = Object.keys(tabs);
                if (remainingTabs.length > 0) {
                    switchToTab(remainingTabs[remainingTabs.length - 1]);
                } else {
                    currentTabId = null;
                    clearCanvas();
                }
            }
            
            renderTabs();
        }

        // Canvas state management
        let zoom = 1;
        let panX = 0;
        let panY = 0;
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;

        function getCurrentZoom() { return zoom; }
        function getCurrentPanX() { return panX; }
        function getCurrentPanY() { return panY; }

        function setCanvasState(tab) {
            zoom = tab.zoom || 1;
            panX = tab.panX || 0;
            panY = tab.panY || 0;
        }

        // API Management
        function saveApiKey() {
            apiKey = document.getElementById('apiKey').value;
            if (apiKey) {
                localStorage.setItem('claude_api_key', apiKey);
                showToast('Clé API sauvegardée', 'success');
                updateApiStatus(true);
                document.getElementById('apiSetup').classList.add('hidden');
            } else {
                showToast('Veuillez entrer une clé API', 'error');
            }
        }

        function loadApiKey() {
            const savedKey = localStorage.getItem('claude_api_key');
            if (savedKey) {
                apiKey = savedKey;
                document.getElementById('apiKey').value = savedKey;
                updateApiStatus(true);
                document.getElementById('apiSetup').classList.add('hidden');
            }
        }

        function updateApiStatus(connected) {
            const indicator = document.getElementById('apiStatus');
            const text = document.getElementById('apiStatusText');
            
            if (connected) {
                indicator.classList.add('active');
                text.textContent = 'Connecté';
            } else {
                indicator.classList.remove('active');
                text.textContent = 'Déconnecté';
            }
        }

        async function testApiConnection() {
            if (!apiKey) {
                showToast('Configurez d\'abord votre clé API', 'error');
                return;
            }

            try {
                const response = await fetch(WORKER_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey
                    },
                    body: JSON.stringify({
                        model: 'claude-3-5-sonnet-20241022',
                        max_tokens: 10,
                        messages: [{
                            role: 'user',
                            content: 'test'
                        }]
                    })
                });

                if (response.ok) {
                    showToast('Connexion réussie!', 'success');
                    updateApiStatus(true);
                } else {
                    showToast('Erreur de connexion', 'error');
                    updateApiStatus(false);
                }
            } catch (error) {
                showToast('Erreur: ' + error.message, 'error');
                updateApiStatus(false);
            }
        }

        // Chat functionality
        function addMessage(content, isUser = false) {
            const messagesContainer = document.getElementById('chatMessages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isUser ? 'user' : 'assistant'}`;
            
            const avatar = isUser ? '👤' : '🤖';
            const sender = isUser ? 'Vous' : 'Assistant Blueprint';
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <div class="message-avatar">${avatar}</div>
                    <span>${sender}</span>
                </div>
                <div class="message-content">${content}</div>
            `;
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const message = input.value.trim();
            
            if (!message) return;
            
            if (!apiKey) {
                showToast('Configurez votre clé API', 'error');
                return;
            }

            addMessage(message, true);
            input.value = '';
            
            const sendBtn = document.getElementById('sendBtn');
            const spinner = document.getElementById('loadingSpinner');
            
            sendBtn.disabled = true;
            spinner.classList.add('active');

            try {
                const response = await fetch(WORKER_API_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey
                    },
                    body: JSON.stringify({
                        model: 'claude-3-5-sonnet-20241022',
                        max_tokens: 4096,
                        system: `Tu es un assistant spécialisé dans la création de Blueprints pour Unreal Engine 5.5/5.6.
                        
                        IMPORTANT: 
                        1. Réponds TOUJOURS avec une brève description (2-3 lignes max)
                        2. NE PAS afficher le JSON dans ta réponse textuelle
                        3. Mets le JSON dans un bloc avec exactement ce format: |||JSON_START|||{json ici}|||JSON_END|||
                        
                        Structure JSON requise:
                        {
                            "name": "Nom du Blueprint",
                            "description": "Description",
                            "version": "UE 5.5/5.6",
                            "nodes": [...],
                            "connections": [...]
                        }`,
                        messages: [{
                            role: 'user',
                            content: message
                        }]
                    })
                });

                const data = await response.json();
                
                if (!response.ok) {
                    throw new Error(data.error?.message || 'Erreur API');
                }

                const responseText = data.content[0].text;
                
                // Extraire le JSON caché
                const jsonMatch = responseText.match(/\|\|\|JSON_START\|\|\|([\s\S]*?)\|\|\|JSON_END\|\|\|/);
                let displayText = responseText;
                
                if (jsonMatch) {
                    // Retirer le JSON du texte affiché
                    displayText = responseText.replace(/\|\|\|JSON_START\|\|\|[\s\S]*?\|\|\|JSON_END\|\|\|/, '').trim();
                    
                    try {
                        const blueprintData = JSON.parse(jsonMatch[1]);
                        
                        // Créer un nouvel onglet avec le Blueprint
                        const tabName = blueprintData.name || 'Blueprint';
                        createNewTab(tabName, blueprintData);
                        
                        showToast(`Blueprint "${tabName}" créé!`, 'success');
                    } catch (e) {
                        console.error('Erreur parsing JSON:', e);
                    }
                }
                
                // Afficher uniquement la description
                addMessage(displayText);

            } catch (error) {
                addMessage(`❌ Erreur: ${error.message}`, false);
                showToast('Erreur: ' + error.message, 'error');
            } finally {
                sendBtn.disabled = false;
                spinner.classList.remove('active');
            }
        }

        function handleChatKeypress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function quickPrompt(text) {
            document.getElementById('chatInput').value = `Crée un Blueprint pour ${text}`;
            document.getElementById('chatInput').focus();
        }

        // Canvas rendering
        function initCanvas() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            setupMouseControls();
            loadApiKey();
            drawGrid();
        }

        function resizeCanvas() {
            const wrapper = document.querySelector('.canvas-wrapper');
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            drawBlueprint();
        }

        function setupMouseControls() {
            canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                dragStartX = e.clientX - panX;
                dragStartY = e.clientY - panY;
            });

            canvas.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    panX = e.clientX - dragStartX;
                    panY = e.clientY - dragStartY;
                    drawBlueprint();
                }
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
            });

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                zoom = Math.max(0.1, Math.min(5, zoom * delta));
                document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
                drawBlueprint();
            });
        }

        function drawGrid() {
            if (!showGrid) {
                ctx.fillStyle = '#0a0a0f';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                return;
            }

            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.strokeStyle = 'rgba(0, 212, 255, 0.05)';
            ctx.lineWidth = 1;
            
            const gridSize = 30 * zoom;
            const offsetX = panX % gridSize;
            const offsetY = panY % gridSize;
            
            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = offsetY; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
        }

        function drawBlueprint() {
            drawGrid();
            
            if (!currentTabId || !tabs[currentTabId]) return;
            
            const blueprintData = tabs[currentTabId].blueprintData;
            if (!blueprintData) return;

            // Draw connections first
            if (blueprintData.connections) {
                blueprintData.connections.forEach(conn => drawConnection(conn, blueprintData));
            }

            // Draw nodes
            if (blueprintData.nodes) {
                blueprintData.nodes.forEach(node => drawNode(node));
            }

            // Update counters
            document.getElementById('nodeCount').textContent = blueprintData.nodes?.length || 0;
            document.getElementById('connectionCount').textContent = blueprintData.connections?.length || 0;
        }

        function drawNode(node) {
            const x = node.position.x * zoom + panX;
            const y = node.position.y * zoom + panY;
            const width = NODE_WIDTH * zoom;
            const height = calculateNodeHeight(node) * zoom;
            
            // Node shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 10 * zoom;
            ctx.shadowOffsetX = 3 * zoom;
            ctx.shadowOffsetY = 3 * zoom;
            
            // Node colors by category
            const colors = {
                'Event': { main: '#ff4444', dark: '#cc2222' },
                'Action': { main: '#4444ff', dark: '#2222cc' },
                'Variable': { main: '#44ff44', dark: '#22cc22' },
                'Flow': { main: '#ff44ff', dark: '#cc22cc' },
                'Function': { main: '#ffaa44', dark: '#cc8822' },
                'Math': { main: '#44ffff', dark: '#22cccc' },
                'Default': { main: '#888888', dark: '#666666' }
            };
            
            const color = colors[node.category] || colors.Default;
            
            // Node background
            const gradient = ctx.createLinearGradient(x, y, x, y + height);
            gradient.addColorStop(0, color.dark + 'dd');
            gradient.addColorStop(1, color.dark + '99');
            ctx.fillStyle = gradient;
            ctx.fillRect(x, y, width, height);
            
            // Node header
            const headerGradient = ctx.createLinearGradient(x, y, x, y + HEADER_HEIGHT * zoom);
            headerGradient.addColorStop(0, color.main);
            headerGradient.addColorStop(1, color.dark);
            ctx.fillStyle = headerGradient;
            ctx.fillRect(x, y, width, HEADER_HEIGHT * zoom);
            
            ctx.shadowColor = 'transparent';
            
            // Node border
            ctx.strokeStyle = color.main;
            ctx.lineWidth = 2 * zoom;
            ctx.strokeRect(x, y, width, height);
            
            // Node title
            ctx.fillStyle = '#ffffff';
            ctx.font = `bold ${14 * zoom}px -apple-system, BlinkMacSystemFont, sans-serif`;
            ctx.fillText(node.type, x + 10 * zoom, y + 22 * zoom);
            
            // Draw pins
            drawPins(node, x, y, width);
        }

        function drawPins(node, x, y, width) {
            // Input pins
            if (node.inputs) {
                node.inputs.forEach((input, i) => {
                    const pinY = y + (HEADER_HEIGHT + 15 + i * PIN_HEIGHT) * zoom;
                    
                    ctx.beginPath();
                    ctx.arc(x - 1, pinY, PIN_RADIUS * zoom, 0, Math.PI * 2);
                    ctx.fillStyle = getPinColor(input.type);
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1 * zoom;
                    ctx.stroke();
                    
                    if (showLabels) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `${11 * zoom}px -apple-system, BlinkMacSystemFont, sans-serif`;
                        ctx.fillText(input.name, x + 12 * zoom, pinY + 4 * zoom);
                    }
                });
            }
            
            // Output pins
            if (node.outputs) {
                node.outputs.forEach((output, i) => {
                    const pinY = y + (HEADER_HEIGHT + 15 + i * PIN_HEIGHT) * zoom;
                    
                    ctx.beginPath();
                    ctx.arc(x + width + 1, pinY, PIN_RADIUS * zoom, 0, Math.PI * 2);
                    ctx.fillStyle = getPinColor(output.type);
                    ctx.fill();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1 * zoom;
                    ctx.stroke();
                    
                    if (showLabels) {
                        ctx.fillStyle = '#ffffff';
                        ctx.font = `${11 * zoom}px -apple-system, BlinkMacSystemFont, sans-serif`;
                        ctx.textAlign = 'right';
                        ctx.fillText(output.name, x + width - 12 * zoom, pinY + 4 * zoom);
                        ctx.textAlign = 'left';
                    }
                });
            }
        }

        function drawConnection(connection, blueprintData) {
            const fromNode = blueprintData.nodes.find(n => n.id === connection.from.nodeId);
            const toNode = blueprintData.nodes.find(n => n.id === connection.to.nodeId);
            
            if (!fromNode || !toNode) return;
            
            const fromPin = fromNode.outputs?.find(p => p.id === connection.from.pinId);
            const toPin = toNode.inputs?.find(p => p.id === connection.to.pinId);
            
            if (!fromPin || !toPin) return;
            
            const fromIndex = fromNode.outputs.indexOf(fromPin);
            const toIndex = toNode.inputs.indexOf(toPin);
            
            const x1 = (fromNode.position.x + NODE_WIDTH) * zoom + panX;
            const y1 = (fromNode.position.y + HEADER_HEIGHT + 15 + fromIndex * PIN_HEIGHT) * zoom + panY;
            const x2 = toNode.position.x * zoom + panX;
            const y2 = (toNode.position.y + HEADER_HEIGHT + 15 + toIndex * PIN_HEIGHT) * zoom + panY;
            
            const color = getPinColor(fromPin.type);
            ctx.strokeStyle = color;
            ctx.lineWidth = (fromPin.type === 'exec' ? 3 : 2) * zoom;
            
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            const cp1x = x1 + Math.abs(x2 - x1) * 0.5;
            const cp2x = x2 - Math.abs(x2 - x1) * 0.5;
            ctx.bezierCurveTo(cp1x, y1, cp2x, y2, x2, y2);
            ctx.stroke();
        }

        function getPinColor(type) {
            const colors = {
                'exec': '#ffffff',
                'bool': '#ff0000',
                'int': '#00ffff',
                'float': '#00ff00',
                'string': '#ff00ff',
                'object': '#0088ff',
                'vector': '#ffaa00',
                'rotator': '#ff8800',
                'default': '#888888'
            };
            return colors[type] || colors.default;
        }

        function calculateNodeHeight(node) {
            const maxPins = Math.max(
                (node.inputs?.length || 0),
                (node.outputs?.length || 0)
            );
            return Math.max(NODE_MIN_HEIGHT, HEADER_HEIGHT + maxPins * PIN_HEIGHT + 15);
        }

        // View controls
        function zoomIn() {
            zoom = Math.min(zoom * 1.2, 5);
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            drawBlueprint();
        }

        function zoomOut() {
            zoom = Math.max(zoom * 0.8, 0.1);
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            drawBlueprint();
        }

        function resetView() {
            zoom = 1;
            panX = 0;
            panY = 0;
            document.getElementById('zoomLevel').textContent = '100%';
            drawBlueprint();
        }

        function fitToView() {
            if (!currentTabId || !tabs[currentTabId]?.blueprintData) return;
            
            const blueprintData = tabs[currentTabId].blueprintData;
            if (!blueprintData.nodes || blueprintData.nodes.length === 0) return;
            
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;
            
            blueprintData.nodes.forEach(node => {
                minX = Math.min(minX, node.position.x);
                minY = Math.min(minY, node.position.y);
                maxX = Math.max(maxX, node.position.x + NODE_WIDTH);
                maxY = Math.max(maxY, node.position.y + calculateNodeHeight(node));
            });
            
            const width = maxX - minX;
            const height = maxY - minY;
            
            const scaleX = (canvas.width - 100) / width;
            const scaleY = (canvas.height - 100) / height;
            zoom = Math.min(scaleX, scaleY, 2);
            
            const centerX = (minX + maxX) / 2;
            const centerY = (minY + maxY) / 2;
            
            panX = canvas.width / 2 - centerX * zoom;
            panY = canvas.height / 2 - centerY * zoom;
            
            document.getElementById('zoomLevel').textContent = Math.round(zoom * 100) + '%';
            drawBlueprint();
        }

        function autoArrange() {
            if (!currentTabId || !tabs[currentTabId]?.blueprintData) return;
            
            const blueprintData = tabs[currentTabId].blueprintData;
            if (!blueprintData.nodes) return;
            
            const nodes = blueprintData.nodes;
            const layers = [];
            const visited = new Set();
            
            // Find starting nodes
            const startNodes = nodes.filter(n => 
                !n.inputs || n.inputs.length === 0 || n.category === 'Event'
            );
            
            // Build layers
            let currentLayer = startNodes;
            let layerIndex = 0;
            
            while (currentLayer.length > 0 && layerIndex < 10) {
                layers[layerIndex] = currentLayer;
                currentLayer.forEach(n => visited.add(n.id));
                
                const nextLayer = [];
                currentLayer.forEach(node => {
                    if (blueprintData.connections) {
                        blueprintData.connections.forEach(conn => {
                            if (conn.from.nodeId === node.id) {
                                const targetNode = nodes.find(n => n.id === conn.to.nodeId);
                                if (targetNode && !visited.has(targetNode.id)) {
                                    if (!nextLayer.find(n => n.id === targetNode.id)) {
                                        nextLayer.push(targetNode);
                                    }
                                }
                            }
                        });
                    }
                });
                
                currentLayer = nextLayer;
                layerIndex++;
            }
            
            // Position nodes
            const HORIZONTAL_SPACING = 350;
            const VERTICAL_SPACING = 150;
            
            layers.forEach((layer, layerIdx) => {
                let currentY = 100;
                layer.forEach(node => {
                    node.position.x = 100 + layerIdx * HORIZONTAL_SPACING;
                    node.position.y = currentY;
                    currentY += calculateNodeHeight(node) + VERTICAL_SPACING;
                });
            });
            
            drawBlueprint();
        }

        function toggleLabels() {
            showLabels = !showLabels;
            document.getElementById('labelsBtn').classList.toggle('active');
            drawBlueprint();
        }

        function toggleGrid() {
            showGrid = !showGrid;
            document.getElementById('gridBtn').classList.toggle('active');
            drawBlueprint();
        }

        function clearCanvas() {
            ctx.fillStyle = '#0a0a0f';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            document.getElementById('nodeCount').textContent = '0';
            document.getElementById('connectionCount').textContent = '0';
        }

        // Export functionality
        function exportCurrentBlueprint() {
            if (!currentTabId || !tabs[currentTabId]?.blueprintData) {
                showToast('Aucun Blueprint à exporter', 'error');
                return;
            }
            
            const blueprintData = tabs[currentTabId].blueprintData;
            const json = JSON.stringify(blueprintData, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${blueprintData.name || 'blueprint'}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Blueprint exporté!', 'success');
        }

        // Toast notifications
        function showToast(message, type = 'success') {
            const existingToast = document.querySelector('.toast');
            if (existingToast) {
                existingToast.remove();
            }
            
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.innerHTML = `
                <div class="toast-icon">${type === 'success' ? '✓' : '!'}</div>
                <span>${message}</span>
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function showHelp() {
            showToast('Documentation bientôt disponible', 'success');
        }

        // Initialize
        initCanvas();
    </script>
</body>
</html>